# Caravel User Project

##Model Predictive Control (MPC):
Model Predictive Control is an advanced control strategy used in industrial automation and control systems. It is a feedback control method that uses a dynamic mathematical model of the system being controlled to make predictions about its future behavior. Based on these predictions, the controller optimizes a control signal over a finite time horizon to drive the system towards desired performance.
The main steps involved in MPC are as follows:

System Modeling: A mathematical model of the system is developed based on its physical characteristics and behavior. This model describes how the system responds to control inputs and disturbances.
Prediction: Using the model, predictions are made about the future behavior of the system over a finite time horizon. This involves propagating the model forward in time and accounting for expected disturbances.
Optimization: An objective function is defined to measure the system's performance. The control inputs are optimized to minimize the objective function while satisfying system constraints.
Control Signal Calculation: The optimized control inputs for the current time step are applied to the system. The process is repeated at each time step, with the horizon shifting forward in time.
MPC offers several advantages, including the ability to handle constraints on inputs and outputs, the ability to handle multivariable systems, and the capability to account for system dynamics and future predictions. It is widely used in various industries such as process control, robotics, and autonomous systems.

##Verilog Code for the FCS_MPC Module:
Now let's analyze the Verilog code provided for the FCS_MPC module:
The module declaration defines an MPC controller with three input signals: iL, vc, and Vg. It also has an output signal u that represents the control signal generated by the MPC controller.

Inside the module, there is a 40-bit temp variable to store intermediate calculations. This bit width is adjusted to accommodate the multiplication and addition/subtraction operations.

The module also includes a function called abs that takes an input value x and returns its absolute value. This function is used to compute the absolute value of temp in the main always block.

The always block is sensitive to changes in iL, vc, or Vg. Within this block, the MPC calculations are performed. The equation for temp involves multiplication of iL and vc with specific 40-bit constant values, and then subtraction of another 40-bit constant. The result is stored in temp.

The output u is computed based on the absolute value of temp plus a 40-bit constant multiplied by Vg. If the absolute value of this sum is less than or equal to the absolute value of temp, u is set to 1; otherwise, it is set to 0.

Please note that the specific values of the constant multipliers and the equations used in the MPC calculations are not provided in the code snippet, so the exact behavior and output values cannot be determined without this information.

The test bench code is responsible for generating test vectors for iL, vc, and Vg inputs. The clock clk is defined, and the module under test (FCS_MPC) is instantiated.

In the initial block of the test bench, the values of iL and vc are initialized to the lower bounds of their respective ranges. Then, a repeat loop is used to iterate 10 times, incrementing vc by 1 and iL by 1 within their specified ranges. `vg

## Prompt
/home/asma_mohsin/Downloads/WhatsApp Image 2023-05-19 at 3.10.44 PM.jpeg
/home/asma_mohsin/Downloads/WhatsApp Image 2023-05-19 at 3.11.20 PM.jpeg

Brad is used to generate the MPC model by feeding in the equation. The following command was used

Convert the following MATLAB code to a fixed point verilog module with 32 bit signed Q4.28 fixed point width for all constants and inputs. Internal variable temp should be 64 bits wide. The output should be a single bit. function u = FCS_MPC(iL, vc, Vg) Vref = 32'b001010000000000000000000000000000; temp = (32'b00000111100111010101111010011001 * iL + 32'b00000111100001111010110101111110 * vc - Vref); if abs(temp + 32'b00000000000000000001110000000111 * Vg) <= abs(temp) u = 1; else u = 0; end Implement the abs() function as a synthesizable verilog function INSIDE the module, with 64 bit input width. 


Then it was modified using chatpgpt
https://chat.openai.com/share/e7dd4c11-2ef3-4fa0-86d8-30cf6c59bfd5
